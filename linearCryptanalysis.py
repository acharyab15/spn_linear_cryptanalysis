'''
linearCryptanalysis.py

This framework is an implementation of linear cryptanalysis of a substitution-permutation network.

This is an open source software and can be redistributed or modified as deemed appropriate.

Credits: https://github.com/keithmgould/cryptanalysis.git

Copyright (C) 2015 Bipeen Acharya

'''
SBOXFORWARD =  [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7]
SBOXBACKWARD = [14,3,4,8,1,12,10,15,7,13,9,6,11,2,0,5]
PERMUTATION =  [0,4,8,12,1,5,9,13,2,6,10,14,3,7,11,15]

from random import randrange

approxTable = [[0]*16 for i in range(16)]
knownPlaintext = [0]*10000
knownCiphertext = [0]*10000

"""
Convert a binary string into an integer
"""
def intConv(value):
    string = ''
    for i in value:
        string+= str(i)
    return int(string, 2)

"""
Performing a bit by bit XOR sum of two blocks of data
"""
def xorSum(block_one, block_two):
    return [x^y for x,y in zip(block_one, block_two)]

"""
Performing the sbox substitution on the value
value: 16 bit array

"""
def sboxSub(value, direction):
    #create 4 slices of 4 bits each
    slices = (value[i * 4:(i + 1) * 4] for i in range(4)) 
    fin = [0]*16
    hexes = [intConv(s) for s in slices]
    if direction == "forward":
        direct = SBOXFORWARD
    else:
        direct = SBOXBACKWARD
    c = 4
    #pass each hex value through the sbox and add it to a final array
    for i in range(len(hexes)):
        temp = hexToBinArray(direct[hexes[i]])
        for j in range(len(temp)):
            fin[i*c+j] = int(temp[j])
    return fin

"""
Convert a hex value to a binary array
"""
def hexToBinArray(val):
    binStr = '{0:04b}'.format(val)
    binArr = [0]*4
    for i in range(len(binStr)):
        binArr[i] = int(binStr[i])
    return binArr

"""
Returns the result of passing a value backwards through the sbox 
"""
def forward(key,state,skip_permuter = "false"):
    state = xorSum(state,key)
    state = sboxSub(state, "forward")

    if skip_permuter == "false":
        state = permute(state)
    return state

"""
Returns the result of passing a value backwards through the sbox 
"""
def backward(key, state, skip_permuter = "false"):
    if skip_permuter == "false":
        state = permute(state)
    state = sboxSub(state, "backward")
    return xorSum(state, key)

"""
Returns the result of permuting the bits of a value by passing it to the permutation box
"""
def permute(value):
    return [value[PERMUTATION[i]] for i in range(16)]

"""
4 round encryption that involves iteratively passing 16-bits of the key and the respective result of previous round encryption.
value is 16 bits
key is 80 bits
"""
def encrypt(value, key):
    
    results = forward(key[0:16], value)
    results = forward(key[16:32], results)
    results = forward(key[32:48], results)
    results = forward(key[48:64], results, "true")
    return xorSum(results, key[64:80])

"""
4 round decryption that involves iteratively passing 16-bits of the key and the respective result of previous round decryption.
value is 16 bits
key is 80 bits
"""
def decrypt(value, key):
    #value is 16 bits
    #key is 80 bits
    results = xorSum(value, key[64:80])
    results = backward(key[48:64], results, "true")
    results = backward(key[32:48], results)
    results = backward(key[16:32], results)
    return backward(key[0:16], results)

"""
Creating a linear approximation table
Apply the input mask to the input. Apply the output mask to the output provided by the sbox/
If they are equal, then the corresponding table value is incremented.
"""
def determineBest():
    for outputMask in range(1,16):
        for inputMask in range(1,16):               
            for inputValue in range(16):                
            #check if input w/ input mask == output w/ output mask
                if (applyMask(inputValue,inputMask) == applyMask(SBOXFORWARD[inputValue], outputMask)):                 
                    approxTable[inputMask][outputMask] += 1

"""
Apply the masks by choosing certain bits to XOR
Here, bits are XORed only if the i'th value of the mask is a 1.
"""
def applyMask( inputValue, mask):
    maskBin = '{0:04b}'.format(mask)
    inputBin = '{0:04b}'.format(inputValue)
    total = 0
    for i in range(4):
        if int(maskBin[i]) == 1:
            total = total ^ int(inputBin[i])
    return total

"""
Print the approximation table that was generated by the determineBest() method
"""
def showApproximationTable():
    for c in range(1,16):
        for d in range(1,16):
            print ("%d" %(approxTable[c][d]-8)) ,
    print

"""
Generate known pairs

Plaintexts are generating as a random 16-bit binary sequence
Ciphertexts are generating by encrypting the corresponding plaintexts
"""
def generateKnownPairs(key, pair_count):
    pairs = {}
    for i in range(pair_count):
        if i % 100 == 0:  print (".", end = "")  #XXX how to flush print?
        knownPlaintext[i] = [randrange(2) for j in range(16)]
        knownCiphertext[i] = encrypt(knownPlaintext[i], key)

matches = [-1]*10000
goodkey0 = [0]*10000
goodkey1 = [0]*10000


def xOr(a, b):
	return a^b

"""
Automate the process of generating a linear expression when an approximation is given
"""
def automatePaths(L):
    i = 0
    Pstring = ''
    for j in range(len(L)):
        for k in range(len(L[i])):
            if int(L[i][j][k]) == 1:
                Pstring += "P" + str(j*4 + k) + " + "
    Pstring = Pstring[0:len(Pstring) - 2]

    i = len(L) - 1
    Cstring = ''
    for j in range(len(L)):
        for k in range(len(L[i])):
            if int(L[i][j][k]) == 1:
                Cstring += "U" + str(i+1) + "," + str(j*4 + k) + " + "
    Cstring = Cstring[0:len(Cstring) - 2]
    
    print(Pstring + " + " + Cstring + " = 0")

#Validate the paths for linear cryptanalysis
def validatePaths(L):
    for i in range(len(L)-1):
        for j in range(len(L[i])):
            for k in range(4,len(L[i][j])):
                outputVal = L[i][j][k]
                inputVal = L[i+1][k-4][j]
                if inputVal != outputVal:
                    return "Invalid Path"
            if (L[i][j][0:4] == [0,0,0,0] and L[i][j][4:8] != [0,0,0,0]) or \
               (L[i][j][0:4] != [0,0,0,0] and L[i][j][4:8] == [0,0,0,0]):
                return "Invalid substitution"  
    return "Valid Path"

#Generate random approximations
def generatePaths():
    L= [[[0 for i in range(8)] for j in range(4)] for j in range(4)]
    for j in range(4):
        a = [random.randrange(2) for j in range(4)]
        if a == [0,0,0,0]:
            a = [0,0,0,0,0,0,0,0]
        else:
            b = [random.randrange(2) for j in range(4)]
            while b == [0,0,0,0]:
                b = [random.randrange(2) for j in range(4)]
            a.extend(b)
        L[0][j] = a

    for i in range(1,4):
        for j in range(4):
            for k in range(4):
                L[i][k][j] = L[i-1][j][k+4]

        for j in range(4):
            if L[i][j][0:4] == [0,0,0,0]:
                L[i][j][0:8] = [0,0,0,0,0,0,0,0]
            elif L[i][j][0:4] != [0,0,0,0]:
                b = [random.randrange(2) for j in range(4)]
                while b == [0,0,0,0]:
                    b = [random.randrange(2) for j in range(4)]
                L[i][j][0:8] = L[i][j][0:4]+b
                
    print(validatePaths(L))


    for i in range(3):
        for j in range(4):
            stringX, stringY = "", ""
            for k in range(8):
                if L[i][j][k] != 0:
                    if k < 4:
                        stringX += "X" + str(k) + " + "
                    else:
                        stringY += "Y" + str(k-4) + " + "
            if stringX != '':
                stringX = stringX[0:len(stringX) - 2]
                stringY = stringY[0:len(stringY) - 2]
                string = stringX + " = " + stringY
                print ("S" + str(i+1) + str(j+1) + ": " + string)



"""
After the known pairs have been generated, this method runs through them to determine the keys
pair_count: the total number of known pairs
"""
def runThroughKnownPairs(pair_count):
    matches = {}
    for i in range(pair_count):
        plain = knownPlaintext[i]
        cipher = knownCiphertext[i]
        #sbox42_key is all the 4-bit possibilities for the subkey in round 4 sbox 2.
        for sbox42_key in range(16): 
            xor42 = sbox42_key ^ intConv(cipher[4:4+4])
            #passing xor42 backwards gives the value before passing through the round 4 sbox 2 
            unsub42 = hexToBinArray(SBOXBACKWARD[xor42])
            #sbox44_key is all the 4-bit possibilities for the subkey in round 4 sbox 4.
            for sbox44_key in range(16):        
                if not ("%d-%d" %(sbox42_key, sbox44_key)) in matches:
                    matches["%d-%d" %(sbox42_key, sbox44_key)] = 0
                xor44 = sbox44_key ^ intConv(cipher[12:12+4])
                unsub44 = hexToBinArray(SBOXBACKWARD[xor44])
                #Taking the respective unsubstituted bits according to the diagram in the tutorial
                if unsub42[1] ^ unsub42[3] ^ unsub44[1] ^ unsub44[3] ^ plain[4] ^ plain[6] ^ plain[7] == 0 :
                    matches["%d-%d" %(sbox42_key, sbox44_key)] += 1
    
    return matches

"""
Return a sorted representation of a dictionary 
"""
def sortedDictionary(dictToSort):
    import operator
    sorted_Dict = sorted(dictToSort.items(), key = operator.itemgetter(1))  #XXX how to sort dictionary. also, sort values by abs(value - 5000)
    return sorted_Dict

def attack():
    unknown_key = [randrange(2) for i in range(80)]
    #determineBest()
    #showApproximationTable()

    L = [['00000000', '10110100', '00000000', '00000000'], \
         ['00000000', '01000101', '00000000', '00000000'], \
         ['00000000', '01000101', '00000000', '01000101'], \
         ['00000000', '01010000', '00000000', '01010000']]

    print(automatePaths(L))
    print(validatePaths(L))
    print("building 10,000 known pairs...")
    known_pairs = generateKnownPairs(unknown_key, 10000)

    print("processing 10,000 known pairs...")
    matchDict = runThroughKnownPairs(10000)

    sortedDict = sortedDictionary(matchDict)
    print(sortedDict)
    "Here are the 10 best results from analysis:"
    for i in range(10):
        print("%s ==> %f" %(sortedDict[i][0], abs(sortedDict[i][1] - 5000)/ float(10000)))

    print("unknown subkey 5 bits 4-7:", unknown_key[68:72])
    print("unknown subkey 5 bits 12-15:", unknown_key[76:80])

	

    print("The top result from analysis reveals the same amount (in base16) as the unknown subkeys.")
    
attack()
    
